#!/bin/bash

# HITL Platform - Enhanced Build Pipeline Script
# Orchestrates the complete build and deployment process with AMI integration

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
PROJECT_NAME="hitl"
BUILD_VERSION="$(date +%Y%m%d-%H%M%S)"

# Default values
AWS_REGION="${AWS_REGION:-us-east-1}"
ENVIRONMENT="${ENVIRONMENT:-dev}"
BUILD_AMI="${BUILD_AMI:-true}"
DEPLOY_INFRASTRUCTURE="${DEPLOY_INFRASTRUCTURE:-false}"
USE_TERRAFORM="${USE_TERRAFORM:-true}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')] INFO:${NC} $1"
}

warn() {
    echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] WARNING:${NC} $1"
}

error() {
    echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1"
    exit 1
}

info() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')] INFO:${NC} $1"
}

show_help() {
    cat << EOF
HITL Platform Build Pipeline

Usage: $0 [OPTIONS]

Options:
  -r, --region REGION         AWS region (default: us-east-1)
  -e, --environment ENV       Environment (dev/stage/prod, default: dev)
  --no-ami                    Skip AMI building
  --deploy                    Deploy infrastructure after building
  --use-cloudformation        Use CloudFormation instead of Terraform
  --upload-s3 BUCKET          Upload frontend to S3 bucket
  -h, --help                  Show this help message

Examples:
  $0                          Build all components
  $0 --deploy                 Build and deploy infrastructure
  $0 --no-ami --deploy        Deploy using existing AMI
  $0 -e prod --deploy         Build and deploy to production

Environment Variables:
  AWS_REGION                  AWS region override
  ENVIRONMENT                 Environment override
  S3_BUCKET                   S3 bucket for frontend assets
  
EOF
}

check_dependencies() {
    log "Checking dependencies..."
    
    local deps=("aws" "packer" "terraform" "node" "jq")
    local missing=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing+=("$dep")
        fi
    done
    
    if [ ${#missing[@]} -ne 0 ]; then
        error "Missing dependencies: ${missing[*]}"
    fi
    
    # Check AWS credentials
    if ! aws sts get-caller-identity &> /dev/null; then
        error "AWS credentials not configured or invalid"
    fi
    
    log "All dependencies satisfied"
}

build_lambda_backend() {
    log "Building Lambda backend..."
    
    cd "$PROJECT_ROOT/lambda-backend"
    
    if [ ! -f "package.json" ]; then
        error "Lambda backend package.json not found"
    fi
    
    # Install dependencies and build
    npm install
    ./build.sh
    
    if [ ! -f "deployment.zip" ]; then
        error "Lambda deployment.zip not created"
    fi
    
    log "Lambda backend build completed"
}

build_frontend() {
    log "Building React frontend..."
    
    cd "$PROJECT_ROOT/demo-app"
    
    if [ ! -f "package.json" ]; then
        error "Frontend package.json not found"
    fi
    
    # Install dependencies and build
    npm install
    npm run build
    
    if [ ! -d "build" ]; then
        error "Frontend build directory not created"
    fi
    
    log "Frontend build completed"
}

build_ami() {
    log "Building golden AMI..."
    
    cd "$PROJECT_ROOT/ami-builder"
    
    # Run the AMI build script
    ./build-ami.sh --region "$AWS_REGION" --environment "$ENVIRONMENT"
    
    if [ ! -f "latest-ami-id.txt" ]; then
        error "AMI build did not produce AMI ID file"
    fi
    
    local ami_id=$(cat latest-ami-id.txt)
    log "Golden AMI built successfully: $ami_id"
    
    # Update infrastructure configurations
    update_infrastructure_configs "$ami_id"
}

update_infrastructure_configs() {
    local ami_id="$1"
    
    log "Updating infrastructure configurations with AMI ID: $ami_id"
    
    # Update Terraform variables
    local tfvars_file="$PROJECT_ROOT/environments/${ENVIRONMENT}.tfvars"
    if [ -f "$tfvars_file" ]; then
        # Update existing file
        if grep -q "custom_ami_id" "$tfvars_file"; then
            sed -i.bak "s/custom_ami_id = .*/custom_ami_id = \"$ami_id\"/" "$tfvars_file"
        else
            echo "custom_ami_id = \"$ami_id\"" >> "$tfvars_file"
        fi
        log "Updated Terraform variables: $tfvars_file"
    else
        # Create new tfvars file
        cat > "$tfvars_file" << EOF
# Generated by build pipeline $(date)
aws_region = "$AWS_REGION"
environment = "$ENVIRONMENT"
project_name = "$PROJECT_NAME"
custom_ami_id = "$ami_id"
EOF
        log "Created Terraform variables: $tfvars_file"
    fi
    
    # Update CloudFormation parameters
    local cf_params="$PROJECT_ROOT/cloudformation/app-stack/parameters-${ENVIRONMENT}.json"
    if [ -f "$cf_params" ]; then
        # Update CustomAmiId parameter
        jq --arg ami "$ami_id" \
           '(.[] | select(.ParameterKey=="CustomAmiId") | .ParameterValue) = $ami' \
           "$cf_params" > "${cf_params}.tmp" && mv "${cf_params}.tmp" "$cf_params"
        log "Updated CloudFormation parameters: $cf_params"
    fi
}

deploy_infrastructure() {
    if [ "$USE_TERRAFORM" = "true" ]; then
        deploy_terraform
    else
        deploy_cloudformation
    fi
}

deploy_terraform() {
    log "Deploying infrastructure with Terraform..."
    
    # Deploy VPC first
    info "Deploying VPC..."
    cd "$PROJECT_ROOT/terraform/vpc"
    terraform init
    terraform plan -var-file="../../environments/${ENVIRONMENT}.tfvars"
    terraform apply -var-file="../../environments/${ENVIRONMENT}.tfvars" -auto-approve
    
    # Export VPC outputs for app deployment
    terraform output -json > ../app/vpc-outputs.json
    
    # Deploy application infrastructure
    info "Deploying application infrastructure..."
    cd "$PROJECT_ROOT/terraform/app"
    terraform init
    terraform plan -var-file="../../environments/${ENVIRONMENT}.tfvars"
    terraform apply -var-file="../../environments/${ENVIRONMENT}.tfvars" -auto-approve
    
    log "Terraform deployment completed"
}

deploy_cloudformation() {
    log "Deploying infrastructure with CloudFormation..."
    
    cd "$PROJECT_ROOT/cloudformation"
    
    # Deploy VPC stack
    info "Deploying VPC stack..."
    ./deploy.sh vpc "$ENVIRONMENT"
    
    # Deploy application stack
    info "Deploying application stack..."
    ./deploy.sh app "$ENVIRONMENT"
    
    log "CloudFormation deployment completed"
}

upload_frontend_to_s3() {
    local bucket="$1"
    
    if [ -z "$bucket" ]; then
        warn "No S3 bucket specified for frontend upload"
        return
    fi
    
    log "Uploading frontend to S3 bucket: $bucket"
    
    cd "$PROJECT_ROOT/demo-app"
    
    if [ ! -d "build" ]; then
        error "Frontend build directory not found. Run build first."
    fi
    
    aws s3 sync build/ "s3://$bucket/" --delete --region "$AWS_REGION"
    
    log "Frontend uploaded to S3 successfully"
}

show_status() {
    echo ""
    echo "=================================="
    echo "HITL Platform Build Status"
    echo "=================================="
    echo "Build Version: $BUILD_VERSION"
    echo "AWS Region: $AWS_REGION"
    echo "Environment: $ENVIRONMENT"
    echo "Timestamp: $(date)"
    echo ""
    
    # Show AMI status
    if [ -f "$PROJECT_ROOT/ami-builder/latest-ami-id.txt" ]; then
        echo "Latest AMI: $(cat $PROJECT_ROOT/ami-builder/latest-ami-id.txt)"
    else
        echo "Latest AMI: Not built"
    fi
    
    echo ""
    echo "Build Components:"
    [ -f "$PROJECT_ROOT/lambda-backend/deployment.zip" ] && echo "  ✓ Lambda backend" || echo "  ✗ Lambda backend"
    [ -d "$PROJECT_ROOT/demo-app/build" ] && echo "  ✓ Frontend" || echo "  ✗ Frontend"
    [ -f "$PROJECT_ROOT/ami-builder/latest-ami-id.txt" ] && echo "  ✓ Golden AMI" || echo "  ✗ Golden AMI"
    
    echo ""
    echo "Infrastructure State:"
    [ -f "$PROJECT_ROOT/terraform/vpc/terraform.tfstate" ] && echo "  ✓ VPC (Terraform)" || echo "  ✗ VPC (Terraform)"
    [ -f "$PROJECT_ROOT/terraform/app/terraform.tfstate" ] && echo "  ✓ App (Terraform)" || echo "  ✗ App (Terraform)"
    
    echo "=================================="
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -r|--region)
            AWS_REGION="$2"
            shift 2
            ;;
        -e|--environment)
            ENVIRONMENT="$2"
            shift 2
            ;;
        --no-ami)
            BUILD_AMI="false"
            shift
            ;;
        --deploy)
            DEPLOY_INFRASTRUCTURE="true"
            shift
            ;;
        --use-cloudformation)
            USE_TERRAFORM="false"
            shift
            ;;
        --upload-s3)
            S3_BUCKET="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            error "Unknown option: $1"
            ;;
    esac
done

# Main execution
main() {
    echo "=================================="
    echo "HITL Platform Build Pipeline"
    echo "=================================="
    echo "Build Version: $BUILD_VERSION"
    echo "AWS Region: $AWS_REGION"
    echo "Environment: $ENVIRONMENT"
    echo "Build AMI: $BUILD_AMI"
    echo "Deploy Infrastructure: $DEPLOY_INFRASTRUCTURE"
    echo "Use Terraform: $USE_TERRAFORM"
    echo "=================================="
    echo ""
    
    # Check dependencies first
    check_dependencies
    
    # Build components
    build_lambda_backend
    build_frontend
    
    # Build AMI if requested
    if [ "$BUILD_AMI" = "true" ]; then
        build_ami
    fi
    
    # Upload frontend to S3 if specified
    if [ -n "$S3_BUCKET" ]; then
        upload_frontend_to_s3 "$S3_BUCKET"
    fi
    
    # Deploy infrastructure if requested
    if [ "$DEPLOY_INFRASTRUCTURE" = "true" ]; then
        deploy_infrastructure
    fi
    
    # Show final status
    show_status
    
    log "Build pipeline completed successfully!"
}

# Run main function
main "$@"