AWSTemplateFormatVersion: '2010-09-09'
Description: 'HITL Platform - AMI Stack - Creates golden AMI and S3 buckets'

Parameters:
  Environment:
    Type: String
    Description: Environment name (dev, stage, prod)
    AllowedValues: [dev, stage, prod]
    Default: dev

  ProjectName:
    Type: String
    Description: Project name for resource naming
    Default: hitl-cf

  VpcStackName:
    Type: String
    Description: Name of the VPC CloudFormation stack
    Default: hitl-cf-dev-vpc

Resources:
  # IAM role for AMI build instances
  AmiInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-${Environment}-ami-instance-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/EC2InstanceProfileForImageBuilder
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: AmiBuilderCustomPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                  - s3:PutObject
                  - s3:PutObjectAcl
                Resource:
                  - !GetAtt FrontendAssetsBucket.Arn
                  - !Sub '${FrontendAssetsBucket.Arn}/*'
                  - !GetAtt AmiLogsBucket.Arn
                  - !Sub '${AmiLogsBucket.Arn}/*'
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName
        - Key: ManagedBy
          Value: cloudformation
        - Key: Stack
          Value: ami

  # Instance profile
  AmiInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: !Sub '${ProjectName}-${Environment}-ami-instance-profile'
      Roles:
        - !Ref AmiInstanceRole

  # S3 bucket for frontend assets and scripts
  FrontendAssetsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ProjectName}-${Environment}-frontend'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: delete-old-files
            Status: Enabled
            ExpirationInDays: 30
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 1
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName
        - Key: ManagedBy
          Value: cloudformation
        - Key: Stack
          Value: ami

  # S3 bucket for AMI build logs
  AmiLogsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ProjectName}-${Environment}-ami-logs'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName
        - Key: ManagedBy
          Value: cloudformation
        - Key: Stack
          Value: ami

  # Security group for AMI build instances
  AmiSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub '${ProjectName}-${Environment}-ami-sg'
      GroupDescription: Security group for AMI build instances
      VpcId:
        Fn::ImportValue: !Sub '${ProjectName}-${Environment}-vpc-id'
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: HTTPS outbound for AWS APIs
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: HTTP outbound for package downloads
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${Environment}-ami-sg'
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: !Ref ProjectName
        - Key: ManagedBy
          Value: cloudformation
        - Key: Stack
          Value: ami

  # Note: Scripts must be uploaded to S3 bucket separately using:
  # aws s3 cp scripts/ s3://hitl-cf-dev-frontend/scripts/ --recursive

  # AMI build component for nginx and security hardening
  AmiComponent:
    Type: AWS::ImageBuilder::Component
    Properties:
      Name: !Sub '${ProjectName}-${Environment}-nginx-security'
      Description: Install nginx and apply security hardening
      Platform: Linux
      Version: 1.0.9
      Data: !Sub |
        name: nginx-security-hardening
        description: Install nginx with security hardening for HITL Platform
        schemaVersion: 1.0
        phases:
          - name: build
            steps:
              - name: InstallNginx
                action: ExecuteBash
                inputs:
                  commands:
                    - yum update -y
                    - aws s3 cp s3://${FrontendAssetsBucket}/scripts/install-nginx.sh /tmp/ --region ${AWS::Region}
                    - chmod +x /tmp/install-nginx.sh
                    - /tmp/install-nginx.sh
                    - echo 'Downloading and installing scripts from S3...'
                    - aws s3 cp s3://${FrontendAssetsBucket}/scripts/sync-from-s3.sh /usr/local/bin/ --region ${AWS::Region}
                    - chmod +x /usr/local/bin/sync-from-s3.sh
                    - aws s3 cp s3://${FrontendAssetsBucket}/scripts/generate-health.sh /usr/local/bin/ --region ${AWS::Region}
                    - chmod +x /usr/local/bin/generate-health.sh
                    - echo 'Running initial health generation...'
                    - /usr/local/bin/generate-health.sh
      Tags:
        Environment: !Ref Environment
        Project: !Ref ProjectName
        ManagedBy: cloudformation
        Stack: ami

  # Infrastructure configuration
  AmiInfrastructureConfiguration:
    Type: AWS::ImageBuilder::InfrastructureConfiguration
    Properties:
      Name: !Sub '${ProjectName}-${Environment}-infrastructure'
      Description: Infrastructure configuration for HITL golden AMI
      InstanceProfileName: !Ref AmiInstanceProfile
      InstanceTypes: [t3.small]
      SubnetId:
        Fn::ImportValue: !Sub '${ProjectName}-${Environment}-public-subnet-1-id'
      SecurityGroupIds:
        - !Ref AmiSecurityGroup
      Logging:
        S3Logs:
          S3BucketName: !Ref AmiLogsBucket
          S3KeyPrefix: ami-logs
      TerminateInstanceOnFailure: true
      Tags:
        Environment: !Ref Environment
        Project: !Ref ProjectName
        ManagedBy: cloudformation
        Stack: ami

  # Image recipe
  AmiImageRecipe:
    Type: AWS::ImageBuilder::ImageRecipe
    Properties:
      Name: !Sub '${ProjectName}-${Environment}-recipe'
      Description: HITL Platform golden AMI recipe
      ParentImage: !Sub 'arn:aws:imagebuilder:${AWS::Region}:aws:image/amazon-linux-2-x86/x.x.x'
      Version: 1.0.9
      Components:
        - ComponentArn: !Ref AmiComponent
        - ComponentArn: !Sub 'arn:aws:imagebuilder:${AWS::Region}:aws:component/update-linux/x.x.x'
      Tags:
        Environment: !Ref Environment
        Project: !Ref ProjectName
        ManagedBy: cloudformation
        Stack: ami

  # Distribution configuration
  AmiDistributionConfiguration:
    Type: AWS::ImageBuilder::DistributionConfiguration
    Properties:
      Name: !Sub '${ProjectName}-${Environment}-distribution'
      Description: Distribution configuration for HITL golden AMI
      Distributions:
        - Region: !Ref AWS::Region
          AmiDistributionConfiguration:
            Name: !Sub '${ProjectName}-${Environment}-nginx-{{ imagebuilder:buildDate }}'
            Description: HITL Platform nginx server with security hardening - {{ imagebuilder:buildDate }}
            AmiTags:
              Name: !Sub '${ProjectName}-${Environment}-nginx-{{ imagebuilder:buildDate }}'
              BuildDate: '{{ imagebuilder:buildDate }}'
              Source: imagebuilder
              Component: nginx
              Environment: !Ref Environment
              Project: !Ref ProjectName
              ManagedBy: cloudformation
              Stack: ami
      Tags:
        Environment: !Ref Environment
        Project: !Ref ProjectName
        ManagedBy: cloudformation
        Stack: ami

  # Image pipeline
  AmiImagePipeline:
    Type: AWS::ImageBuilder::ImagePipeline
    Properties:
      Name: !Sub '${ProjectName}-${Environment}-pipeline'
      Description: HITL Platform golden AMI pipeline
      ImageRecipeArn: !Ref AmiImageRecipe
      InfrastructureConfigurationArn: !Ref AmiInfrastructureConfiguration
      DistributionConfigurationArn: !Ref AmiDistributionConfiguration
      EnhancedImageMetadataEnabled: true
      ImageTestsConfiguration:
        ImageTestsEnabled: true
        TimeoutMinutes: 60
      Tags:
        Environment: !Ref Environment
        Project: !Ref ProjectName
        ManagedBy: cloudformation
        Stack: ami

  # Lambda role for S3 cleanup
  S3CleanupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Cleanup
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:DeleteObject
                Resource:
                  - !GetAtt FrontendAssetsBucket.Arn
                  - !GetAtt AmiLogsBucket.Arn
                  - !Sub '${FrontendAssetsBucket.Arn}/*'
                  - !Sub '${AmiLogsBucket.Arn}/*'

  # Lambda function to empty buckets on deletion
  S3CleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt S3CleanupRole.Arn
      Timeout: 120
      Code:
        ZipFile: |
          import json
          import logging
          import urllib.request
          import urllib.error
          import boto3
          import time
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          # Inline cfnresponse implementation
          class _CFNResponse:
              SUCCESS = "SUCCESS"
              FAILED = "FAILED"
              
              @staticmethod
              def send(event, context, responseStatus, responseData=None, physicalResourceId=None, noEcho=False, reason=None):
                  responseData = responseData or {}
                  responseBody = {
                      "Status": responseStatus,
                      "Reason": reason or f"See CloudWatch Logs for details: {context.log_stream_name}",
                      "PhysicalResourceId": physicalResourceId or context.log_stream_name,
                      "StackId": event["StackId"],
                      "RequestId": event["RequestId"],
                      "LogicalResourceId": event["LogicalResourceId"],
                      "NoEcho": noEcho,
                      "Data": responseData,
                  }
                  body = json.dumps(responseBody).encode("utf-8")
                  logger.info(f"Responding to CFN with: {responseStatus}")
                  req = urllib.request.Request(
                      event["ResponseURL"],
                      data=body,
                      method="PUT",
                      headers={"content-type": "", "content-length": str(len(body))},
                  )
                  try:
                      with urllib.request.urlopen(req) as resp:
                          logger.info(f"CFN response status: {resp.status}")
                  except Exception as e:
                      logger.exception("Failed to send CFN response")
                      raise
          
          cfnresponse = _CFNResponse
          
          def handler(event, context):
              logger.info("Event: %s", json.dumps(event))
              
              try:
                  request_type = event["RequestType"]
                  props = event.get("ResourceProperties", {})
                  bucket_name = props.get("BucketName", "")
                  
                  if request_type == "Delete":
                      # Clean up S3 bucket on stack deletion
                      logger.info(f"Cleaning bucket: {bucket_name}")
                      s3 = boto3.client('s3')
                      
                      total_deleted = 0
                      start_time = time.time()
                      max_duration = 100  # 100 seconds max (Lambda timeout is 120)
                      
                      # Delete all objects with pagination
                      continuation_token = None
                      while True:
                          # Check elapsed time
                          elapsed = time.time() - start_time
                          if elapsed > max_duration:
                              logger.warning(f"Approaching timeout after {elapsed:.2f}s. Deleted {total_deleted} objects")
                              break
                          
                          # Check remaining Lambda time
                          remaining_time = context.get_remaining_time_in_millis()
                          if remaining_time < 15000:  # Less than 15 seconds
                              logger.warning(f"Lambda timeout approaching. Deleted {total_deleted} objects")
                              break
                          
                          list_kwargs = {'Bucket': bucket_name, 'MaxKeys': 1000}
                          if continuation_token:
                              list_kwargs['ContinuationToken'] = continuation_token
                          
                          response = s3.list_objects_v2(**list_kwargs)
                          objects = response.get('Contents', [])
                          
                          if objects:
                              delete_keys = [{'Key': obj['Key']} for obj in objects]
                              logger.info(f"Deleting {len(delete_keys)} objects")
                              s3.delete_objects(Bucket=bucket_name, Delete={'Objects': delete_keys})
                              total_deleted += len(delete_keys)
                          
                          if not response.get('IsTruncated'):
                              break
                          continuation_token = response.get('NextContinuationToken')
                      
                      elapsed = time.time() - start_time
                      logger.info(f"Cleanup completed in {elapsed:.2f}s. Deleted {total_deleted} objects")
                      
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, 
                                     responseData={"ObjectsDeleted": total_deleted},
                                     physicalResourceId=bucket_name)
                  else:
                      # Create/Update - just acknowledge
                      logger.info(f"{request_type} request - no action needed")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS,
                                     responseData={"Message": f"{request_type} completed"},
                                     physicalResourceId=bucket_name)
                                     
              except Exception as e:
                  logger.exception("Handler failed")
                  # Always notify CloudFormation of failure
                  try:
                      cfnresponse.send(event, context, cfnresponse.FAILED,
                                     responseData={"Error": str(e)},
                                     physicalResourceId=props.get("BucketName", "unknown"))
                  except:
                      pass
                  # Re-raise so Lambda shows as errored
                  raise

  # Custom resources to clean buckets
  CleanFrontendBucket:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt S3CleanupFunction.Arn
      BucketName: !Ref FrontendAssetsBucket

  CleanLogsBucket:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt S3CleanupFunction.Arn
      BucketName: !Ref AmiLogsBucket

Outputs:
  # S3 Buckets
  FrontendAssetsBucket:
    Description: S3 bucket for frontend assets and scripts
    Value: !Ref FrontendAssetsBucket
    Export:
      Name: !Sub '${ProjectName}-${Environment}-frontend-assets-bucket'

  AmiLogsBucket:
    Description: S3 bucket for AMI build logs
    Value: !Ref AmiLogsBucket
    Export:
      Name: !Sub '${ProjectName}-${Environment}-ami-logs-bucket'

  # AMI Build Resources
  AmiPipelineArn:
    Description: AMI build pipeline ARN
    Value: !Ref AmiImagePipeline
    Export:
      Name: !Sub '${ProjectName}-${Environment}-ami-pipeline-arn'

  AmiRecipeArn:
    Description: AMI build recipe ARN
    Value: !Ref AmiImageRecipe
    Export:
      Name: !Sub '${ProjectName}-${Environment}-ami-recipe-arn'

  AmiComponentArn:
    Description: AMI build component ARN
    Value: !Ref AmiComponent
    Export:
      Name: !Sub '${ProjectName}-${Environment}-ami-component-arn'

  # IAM Resources
  AmiInstanceRoleArn:
    Description: AMI build instance role ARN
    Value: !GetAtt AmiInstanceRole.Arn
    Export:
      Name: !Sub '${ProjectName}-${Environment}-ami-instance-role-arn'

  AmiInstanceProfileArn:
    Description: AMI build instance profile ARN
    Value: !GetAtt AmiInstanceProfile.Arn
    Export:
      Name: !Sub '${ProjectName}-${Environment}-ami-instance-profile-arn'

  # Security Group
  AmiSecurityGroupId:
    Description: AMI build security group ID
    Value: !Ref AmiSecurityGroup
    Export:
      Name: !Sub '${ProjectName}-${Environment}-ami-sg-id'